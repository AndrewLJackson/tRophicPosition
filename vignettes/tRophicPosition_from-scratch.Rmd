---
title: "How to use tRophicPosition from scratch"
author: "Claudio Quezada-Romegialli, Andrew L Jackson & Chris Harrod"
date: "25th of May 2016"
output:
  pdf_document:
    fig_caption: yes
    toc: yes
  html_document:
    fig_caption: yes
    toc: yes
  word_document: default
---

# Introduction

In this vignette, we will guide you to all the steps necessary to estimate the
trophic position of one or more species with stable isotopes, in a Bayesian framework.

## What is the trophic position

Stable isotopes have proven ability to capture the complexity of trophic interactions, to identify energy sources and to infer consumer trophic position. **Trophic position** is an important concept used to describe the ecological role of secondary and higher consumers in food webs. However, current methods for estimating trophic position using $\delta_{15}$N stable isotopes are limited and do not fulfil the full potential of the isotopic approach. 

For instance, researchers typically use point estimate for key parameters including trophic enrichment factors and isotopic baselines, and often do not explicitly include within-population variation i.e. that shown by individual consumers. There is a marked need to include such variation both in the calculation of trophic position, but also to provide robust estimates of trophic position (e.g. measures of central tendency and variance).

## The Bayesian model underneath `tRophicPosition`

In this vignette we present an R package `tRophicPosition`, incorporating a Bayesian model for the calculation of trophic position using stable isotopes with one or multiple baselines within the powerful approach of Markov Chain Monte Carlo simulations provided by JAGS and the statistical language R. We modelled consumer and baseline observations using relevant statistical distributions, allowing them to be treated as random variables. The calculation of trophic position – a random parameter– for one baseline follows standard equations linking $\delta_{15}$N enrichment per trophic level and the trophic position of the baseline (e.g. a primary producer or primary consumer). In case of two baselines, a simple mixing model incorporating $\delta_{13}$C allows for the differentiation between two distinct sources of nitrogen, thus including spatial heterogeneity derived from alternatives sources of $\delta_{15}$N.

## Future releases and getting support

As of 25th of May, 2016, we have released the beta-testing version 0.3.5.9000 of `tRophicPosition`. You are encouraged to use it with your own data, and see which pitfalls appears during the use of the package. You can send your questions or commentaries to the google group [tRophicPosition-support](https://groups.google.com/d/forum/trophicposition-support) or directly to the email trophicposition-support@googlegroups.com. You can send your questions to http://stackexchange.com/ http://stackoverflow.com/ or even [Facebook](https://www.facebook.com/groups/stableisotopes/).

We are working in future releases of `tRophicPosition`, so any feedback is appreciated. We are working in establishing seeds (to get reproducible results), more plotting functions, and the multi-baseline version of `tRophicPosition`.

# Installing `tRophicPosition`

In order to use `tRophicPosition`, first you have to install it, either from GitHub, a package archive file or CRAN, and then load the library into memory.

## From GitHub

The easiest way to install the latest version of `tRophicPosition` is to install it from GitHub. In this way you always will have the code updated. You have to install the release version of devtools from CRAN, and RTools which is necessary to use it. If you are using windows, install RTools from here: http://cran.r-project.org/bin/windows/Rtools/. For other operating systems (Linux, Mac) refer to the [README](https://cran.r-project.org/web/packages/devtools/README.html) of devtools.

To install the devtools package from CRAN:
```{r eval = FALSE}
install.packages(devtools)
```

As of 25th of May 2016, the version available on GitHub is the 0.3.5.9000. To install `tRophicPosition` use this code:
```{r eval = FALSE}
library(devtools)
install_github("AndrewLJackson/tRophicPosition")
```

## From a package archive file

Another possibility is to install `tRophicPosition` from a release version, or a beta-testing version, that might be available from a file.
```{r eval = FALSE}
install.packages(file.choose(), repos = NULL)
```

## From CRAN

When the package be available on CRAN, you can install it simply using this code:

```{r eval = FALSE}
install.packages(tRophicPosition)
```

# Working with `tRophicPosition`

Now that you have installed the package, you have to load it into memory:
```{r}
library(tRophicPosition)
```

And then you can check the version you have installed:

```{r}
packageDescription("tRophicPosition")$Version
```

The basic use of `tRophicPosition` (Figure 1) involves at least:

1. Load Isotope Data into R: from csv, txt or xls files, the clipboard or the source you like. You can have your data organized either as a data frame with 4 variables ($\delta^{13}$C, $\delta^{15}$N, Functional Group and Species) or a named list (N and C isotope values for your secondary consumer, one or more baselines, and trophic enrichment factors). We will cover how to load and manipulate data in detail in this vignette.

2. Define a Bayesian model for the calculation of trophic position. Here you have to choose among the models with:
  + One baseline, using the ` jagsOneBaseline()` function,
  + Two baselines with only trophic enrichment factor (TEF) for N, using the ` jagsTwoBaselines()` function, or
  + Two baselines with TEF for both	C and N, using the ` jagsTwoBaselinesFull()` function.
  
3. Initialize the model: feed the Bayesian model defined in (2) with data. Optionally you can define the number of parallel chains and the number of adaptive iterations you want. These options (as well as the Bayesian model and the data) are entered as arguments to the function ` TPmodel()`.

4. Sample the posterior Trophic Position: get the posterior estimates of trophic position with the function ` posteriorTP()`. Here you can define others parameters you want to monitor, besides the trophic position.

5. Analise and plot the data, using ` summary()`, ` plot()`, `trophicDensityPlot()` and other functions.

```{r echo=FALSE, fig.cap='Basic flowchart of trophic position estimation.'}
grid::grid.raster(png::readPNG(system.file("extdata", "flowchart1.png", package = "tRophicPosition")))
```

In the Figure 1 you see the basic flow chart describing these steps. The rounded rectangles (light grey) refers to functions inside or outside the package, the grey rectangle refers to input data, and the grey rectangle with dashed line refers to optional arguments to each function. 

For example, in order to initialize the Bayesian model you just need to load Isotope Data and have defined previously the Bayesian model itself. Establishing the number of baselines and defining the number of parallel chains is optative. These two arguments are defined by default in the `TPmodel()` function. Each of the functions of `tRophicPosition` have a help page, that you can refer to if are not sure how to proceed. Just write a question mark before the function and press enter in the console: `?TPmodel`.

# Loading and saving data

Although loading/saving data for all the packages available in R would be a desirable task, most packages using their own data formats. This is specially true with Isotope Data. We are working in a standardized way to load/save isotope data, but in the mean time, here we will be giving some examples on how to load Isotope data into R, and get it ready to work within `tRophicPosition`. Also, if you want to reproduce the examples, or your own data analysis, this task will be much easier if you save your data properly.

## Loading data from the clipboard

In order to work with `tRophicPosition`, you can have your isotope data in a spreadsheet, organized like this:

dCsc	|	dNsc	|	dCb1	|	dNb1	|	dCb2	|	dNb2	|	deltaC	|	deltaN
---	|	---	|	---	|	---	|	---	|	---	|	---	|	---
-12,8	|	9,08	|	-18	|	4,09	|	-6,75	|	2,87	|	2,64	|	1,04
-12,9	|	9,27	|	-15,7	|	3,91	|	-12,6	|	4,22	|	2,6	|	1,2
-13,3	|	8,79	|	-18,8	|	4,45	|	-8,62	|	2,67	|	2,61	|	2,25
NA	|	NA	|	NA	|	NA	|	-9,52	|	3,41	|	2,62	|	1,85

In this example, each column of the spreadsheet may have several isotope values, and each column way have a different number of values as well. An example of a spreadsheet formatted like this can be found [here]( https://github.com/clquezada/tRophicPosition/blob/master/Spreadsheet_example.xlsx?raw=true).

You can copy to the clipboard a table like the one in the example, with your **own data** directly from the spreadsheet, and probably this is the easiest way to enter data into R. Besides, if you enter data like this (using the exact headers in the example above), it will be in the **format required** by `tRophicPosition` at the same time. The headers stands for the following, *dCsc* is $\delta^{13}$C of the secondary consumer, *dNsc* is $\delta^{15}$N of the secondary consumer, *dCb1* is $\delta^{13}$C of the baseline 1, *dNb1* is $\delta^{15}$N of the baseline 1, *dCb2* is $\delta^{13}$C of the baseline 2, *dNb2* is $\delta^{15}$N of the baseline 2, *deltaC* is $\Delta$C (TEF) for Carbon and *deltaN* is $\Delta$N (TEF) for Nitrogen. The order of the columns may not be the same, but all the columns must be there if you have two baselines available. If you have only one baseline, then you can have less columns (at least dCsc, dNsc, dNb1m, dCb1 and deltaN if you want to plot the data).

Once you have selected all the data (remember to check that you have 8 columns in the [spreadsheets example])( https://github.com/clquezada/tRophicPosition/blob/master/Spreadsheet_example.xlsx?raw=true), copy it to the clipboard, and then use this code in R:

```{r eval = FALSE}
YourOwnDataSet <- read.table("clipboard", header=TRUE, sep="\t",
                       dec=",", strip.white=TRUE)
```

```{r echo=FALSE}
load(system.file("extdata", "YourOwnDataSet", package = "tRophicPosition"))
```
Remember to look for differences in **regional settings**. You have to change the decimal (comma to point) if you are using a different locale than Spanish (change `dec=","` to `dec="."`). The **separator** `"\t"` stands for the tab key (the one that most spreadsheets uses to separate cells). **Header** is `TRUE` because we copied the headers from the spreadsheet. This is important, as we require the each variable has its own name in R.

Once you have entered the data correctly into R, try this code to see if that is true:

```{r}
YourOwnDataSet
```

You can access every column from "YourOwnDataSet" adding a "$" and the name of the variable at the end, for example try:
```{r eval=FALSE}
YourOwnDataSet$dCsc
```

## Loading data from a csv/txt file

Another possibility is to have the data in a txt file, either as a comma separated value (csv) or as a text. In the following example, we will enter data into R from a txt tab delimited file that has the following structure (download this txt example from [here](https://github.com/clquezada/tRophicPosition/blob/master/Altiplano.txt?raw=true)):

Species | FG | d13C | d15N	|
---	|	---	|	---	|	---	|
Amphipod | Baseline | -18.01196599 | 4.090707942	|
Amphipod | Baseline | -15.7457071 | 3.914633069	|
Bivalve | Baseline | -6.756631631 | 2.871995779	|
Bivalve | Baseline | -12.69629824 | 4.223670466	|
Bivalve | Baseline | -8.627629988 | 2.674563177	|
Bivalve | Baseline | -8.654645161 | 2.896213325	|

As you see, this txt file has 4 columns, the first one has the species, then the second column has the functional group, and the last two columns have the isotope values. In order to load a txt file organized like this [txt file](https://github.com/clquezada/tRophicPosition/blob/master/Altiplano.txt?raw=true) we will use the following code:

```{r eval=FALSE}
# This code will open up a dialog to choose the file you just downloaded
Altiplano <- read.table(file.choose(), header=TRUE, sep="\t",
                       dec=".", strip.white=TRUE)
```

```{r echo=FALSE}
Altiplano <- read.table(system.file("extdata", "Altiplano.txt", package = "tRophicPosition"), header=TRUE, sep="\t", dec=".", strip.white=TRUE)
```

The function "file.choose()" opens a dialog to choose a file interactively.

If everything went good, wow we can check the structure of the data:
```{r}
str(Altiplano)
```

When you open a txt file with the `read.table()` function, you get a data.frame object, and in this case it has 62 observations of 4 variables. In this example Species stands for all the species found, FG stands for the functional group of each species, and d13C and d15N are the stable isotope values.

## Saving the data

If you could copy some data from the spreadsheet to the clipboard, and then you were able to enter it into R (with the `read.table("clipboard")` function), you will have an object stored in the *R Environment*. If you didn't change the name, that object is called `YourOwnDataSet`. This object is a `data.frame`.

If you downloaded the txt file and you could open it (using `read.table(file.choose())`), you will also have an object called `Altiplano`, which is also a data frame.

If you want to save the data from the spreadsheet to reuse it later, you can use the `save()` function. In order to save an object you have use a code like this:

```{r eval=FALSE}
save(Altiplano, file = "Altiplano_fish_from_txt_file")
```

If you try to open the saved file in a txt editor, you will see that it is a binary and compressed file, so you may not be able to see it easily outside R. So you have to check and double check what you are saving to a file when you do this.

Another important point when you save (and afterwards load) a file, is that you have to know **where** you are saving your objects. So, you must know previously which is your working directory, and probably you might want to change it as well.

To know which is your working directory use `getwd()`. To change your working directory, use `setwd("C:/path/to/your/directory")`. After changing your working directory you can save your data, and open it several days after, and then re-doing some analysis again. Probably you will want to save all your work in a script.

# Isotope Data

In the above examples we learned to load data from the clipboard/spreadsheet, and also we learned to load some data from a txt file.

If you have previously organized your isotope data as the spreadsheet in the example above, you will easily have it in R, and you can use all the functions within the package. But first, we need to remove `NA` values. This is done using this code:

```{r}
IsotopeData <- lapply(YourOwnDataSet, na.omit)
```

## Screening isotope data

After removing `NA` values, you can use the `tRophicPosition` function `screenIsotopeData()`:

```{r}
screenIsotopeData(IsotopeData)
```

This graph is explained by itself. You will see in the main plot the secondary consumer, the baseline 1 and the baseline 2. The plot also has the mean plus standard deviation bars, so you get a feeling of how your isotope data is. At the top and to the right, you will see a density function representing a smooth density estimate. The key information from the density plot above (representing the $\delta^{13}$C) is that you will clearly see wich one of the two baselines would be the source of the energy that is feeding your species. The density to the right, represents the degree of overlaping between your two sources in the $\delta^{15}$N space.

In this example, the isotope data comes from the High Andes of Chile, the Altiplano. The secondary consumer here is a fish called *Orestias chungaraensis*, and the two baselines represent the baselines (lambda = 2) available at the time of sampling. We will return to this example later.

## Working with data frames

If you load the data from a txt/csv file or other source and you have your species and baselines stacked, then you have to play with the data first. Using the Altiplano.txt example above, we can have a sumary of its content:

```{r}
summary(Altiplano)
```

We will split this data frame into 2 named lists (one for the *Orestias*, and one for the rainbow trout), so we can use them with the functions available from `tRophicPosition`. First, we will take out the $\delta^{13}$C and $\delta^{15}$N values of the baseline 1 and the baseline 2:

```{r}
# We need to separate the baselines
# First we select d15N and d13C for the baseline 1
dNb1 <- Altiplano$d15N[which(Altiplano$FG == "Baseline" & Altiplano$Species != "Bivalve")]
dCb1 <- Altiplano$d13C[which(Altiplano$FG == "Baseline" & Altiplano$Species != "Bivalve")]

# Then we select d15N and d13C for the baseline 2
dNb2 <- Altiplano$d15N[which(Altiplano$Species == "Bivalve")]
dCb2 <- Altiplano$d13C[which(Altiplano$Species == "Bivalve")]
```

In the code above we selected some values from the column `Altiplano$d15N` considering the functional group and the species identity. So, `dNb1` now has the values of $\delta^{15}$N that belongs to the "Baseline" functional group (`Altiplano$FG == "Baseline"`) and (`&`) at the same time whose identity is different of "Bivalve" (`Altiplano$Species != "Bivalve"`).

```{r}
dNb1
```

You can see the values for `dCb1`, `dNb2` and `dCb2` as well:

```{r}
dCb1
dNb2
dCb2
```

Now we want to extract the fish species. This is done with a similar code, but changing the Species value. So, for the *Orestias*:

```{r}
dN_Orestias <- Altiplano$d15N[which(Altiplano$Species == "Orestias")]
dC_Orestias <- Altiplano$d13C[which(Altiplano$Species == "Orestias")]
```

And now we put all these variables together, in a named list (could be a data frame as well):

```{r}
Orestias <- list("dNb1" = dNb1, "dCb1" = dCb1, "dNb2" = dNb2, "dCb2" = dCb2, "dNsc" = dN_Orestias, "dCsc" = dC_Orestias)
```

Why is important to make a named list? Because when we feed the Bayesian model, we have to explicitly state what is the data we have. In this way, you know exactly what are the values for each variable.

Now that we have extracted the isotope values for the *Orestias*, now we do the same for the rainbow trout:

```{r}
# Here we extract all the isotope values filtering to Species == "Rainbow trout"
dN_Trout <- Altiplano$d15N[which(Altiplano$Species == "Rainbow trout")]
dC_Trout <- Altiplano$d13C[which(Altiplano$Species == "Rainbow trout")]

# And we create a named list
Trout <- list("dNb1" = dNb1, "dCb1" = dCb1, "dNb2" = dNb2, "dCb2" = dCb2, "dNsc" = dN_Orestias, "dCsc" = dC_Orestias)
```

## Generating random data and TEF

At this point we have manipulated a data frame that has stacked information of two fish species, and two baselines. But we are lacking the trophic enrichment factors (TEF). Whether you want to use one or two baselines, you will need TEF for Nitrogen. And, if you want to use the full model of Post (2002) (the one that includes $\Delta$Carbon in the mixing model), then you need to have TEF for Carbon as well.

You have 3 options (Figure 2):

1. Use your own values for TEF, that corresponds to your experiment for your model organism of which you (or someone else) have been working on,
2. Use TEF from bibliography, or
3. Simulate some TEF values, given a mean and standard deviation.

```{r echo=FALSE, fig.cap='Basic flowchart of loading and saving isotope data.'}
grid::grid.raster(png::readPNG(system.file("extdata", "flowchart2.png", package = "tRophicPosition")))
```

In this flow chart light grey squared rectangles refers to functions within `tRophicPosition`, grey rectangles are input/output data, and white rectangles are questions on how to proceed. 

### Generating random isotope data

If you don't have your own data, then you can use the function `generateTPData()`. Every time you call to this function, you will have some random data to use within the package. This is useful for Us to check the performance of the package, and it may be helpful to you, if you don't have data and want to test the package.

The function `generateTPData()` return a named list, so you have to assign it to a variable:

```{r}
myRandomData <- generateTPData()
```

And afterwards, you can plot the data:

```{r}
screenIsotopeData(myRandomData)
```

Remember, every function has its own help file, so if you don't know what arguments receives a function, or you are not sure what kind of data it returns, then use a "?" before the function you want to get help of: `?generateTPData`.

### Generating TEF from bibliography

Getting trophic enrichment factors (TEF) can be sometimes difficult. You can have them in your txt or spreadsheet and load them into R, or you can use two functions we have written to get them.

If you have a rough idea of the mean and standard deviation of the TEF for your organism, then you can use the function `TEF()`. By default this function returns 56 values with a mean 3.4 +- 0.98 sd values for $\Delta$N, and 107 values with a mean 0.39 +- 1.3 sd for $\Delta$C.

But we want to have the data from McCutchan et al (2003), so we have to state the `author` as `"McCutchan"`, and the muscle data (`type = "muscle"`) for both N and C (`element = "both"`). As usual, as this function returns a list, you have to assign it to a variable:

```{r}
McCutchanTEF <- TEF(author = "McCutchan", type = "muscle", element = "both")
```
 If you want to add them to a data frame or to a named list you have previously created, the procedure is quite simple. For example:
 
```{r}
str(Orestias)
```

*Orestias* is a named list with 6 variables: dNb1, dCb1, dNb2, dCb2, dNsc and dCsc. As that list doesn't have TEF, we may want to add the one we got from bibliography:

```{r}
# In this line we add deltaN of McCutchanTEF to Orestias
Orestias$deltaN <- McCutchanTEF$deltaN

# and with this line we do the same but with deltaC
Orestias$deltaC <- McCutchanTEF$deltaC
```

And now the named list `Orestias` has now 8 variables:
```{r}
str(Orestias)
```

### Simulating TEF given a mean and standard deviation

We might want to add TEF for a species, but we don't have bibliographic information to do it. In this case, we can simulate data with the function `simulateTEF()`. If you don't state any arguments, this function returns by default 56 values for Nitrogen and 107 for Carbon -- which are the same values used by Post. But, we won't want to use those values, instead we want:

```{r}
simulatedTEFValues <- simulateTEF(nN = 15, meanN = 1.5, sdN = 1, nC = 15, meanC = 0.25, sdC = 0.5)
```

In this case we also have to include them to the data frame or named list that doesn't have TEF values, or we want to replace them. We will do it for the rainbow trout:

```{r}
Trout$deltaN <- simulatedTEFValues$deltaN
Trout$deltaC <- simulatedTEFValues$deltaC
```

# Defining the Bayesian model for trophic position

Now that you know the basics for loading and saving Isotope Data, and you are able to generate or simulate trophic enrichment factors values, we are ready to get into the core of `tRophicPosition`. Depending on how many baselines you have, and if you want to use the simple (only $\Delta$N) or the full (both $\Delta$N and $\Delta$C) model, you may choose among the three Bayesian models we have implemented in `tRophicPosition`. This is shown in Figure 3.

```{r echo=FALSE, fig.cap='Basic flowchart for defining the Bayesian model for the estimation of trophic position.'}
grid::grid.raster(png::readPNG(system.file("extdata", "flowchart3.png", package = "tRophicPosition")))
```

## Only one baseline

If you want to implement the simplest model, then `jagsOneBaseline()` is the function you need to use. This function by default returns a string defining a Bayesian model with uninformative *priors*. This model implements an estimation of trophic position using the following equation:

(@foo) $\delta^{15}N_{sc} = \delta^{15}N_{b} + \Delta N  (TP - \lambda)$

where $\delta^{15}N_{sc}$ refers to the secondary consumer, $\delta^{15}N_{b}$ refers to the baseline, $\Delta$N is the TEF for Nitrogen, $TP$ is the trophic position of the secondary consumer, and $\lambda$ is the trophic position of the baseline. 

Both $\delta^{15}N_{sc}$ and $\delta^{15}N_{b}$ are modelled as having a normally distributed mean $\mu_{sc}$ and $\mu_b$ respectivelly. They are both also modelled with a uniform *prior* for the standard deviation ($\sigma$) between 0 and 100. The standard deviation is modelled (because of the implementation of BUGS) as tau ($\tau$), which in turn is calculated as ($\tau_{b} = 1/\sigma_{b}$).

Without stating any argument, `jagsOneBaseline()` returns a jags model as a character string that you have to assign to a variable. So, you have to do something like this in order to use it:

```{r}
model.string <- jagsOneBaseline()
```

By default, `jagsOneBaseline()` (and the other more complex models) uses $\lambda = 2$ if you do not explicitely define it. If, for example, you want to calculate the trophic position for a species whose baseline is a primary producer (e.g. phytoplancton), then you have to define $\lambda = 1$. This is done with:

```{r}
model.string <- jagsOneBaseline(lambda = 1)
```

If you have some information for your organism (given stomach content analysis for example), you may define a *prior* distribution for the trophic position of it. By default trophic position is calculated as a random parameter with a uniform prior with lower and upper boundaries between $\lambda$ and 10. If $\lambda = 2$, then by default this *prior* gives you an uniform *prior* distribution between 2 and 10.

If you have information that your species has a trophic position of 3, given the stomach content analys, then you can define a *prior* distribution that includes your previous knowledge in order to improve the calculation of the trophic position. This is done either with:

```{r}
# defining a uniform prior between lambda and 4
model.string <- jagsOneBaseline(TP = "dunif(lambda, 4)", lambda = 1)
```

or giving a normal prior (or other distribution you may think appropriate)

```{r}
# defining a normal prior distribution with mean 3 and sd 0.5, with lambda = 1.
model.string <- jagsOneBaseline(TP = "dnorm(3, 0.5)", lambda = 1)
```

You can define the *priors* for the mean of the baseline (`muB`), the precision for the baseline (`sigmaB`), the mean of the $\Delta$N (`muDeltaN`), precision for $\Delta$N (`sigmaDeltaN`), and both trophic position (`TP`) and $\lambda$ (`lambda`).

## Two baselines with only TEF for N

This model implements a different equation for the calculation of trophic position: 

(@foo2) $\delta^{15}N_{sc} = \Delta N  (TP + \lambda) + \alpha (\delta^{15}N_{b1} + \delta^{15}N_{b2}) - \delta^{15}N_{b2}$

And also includes a simple mixing model to calculate $\alpha$, which allows to estimate the relative contribution of each source to the consumer's trophic position:

(@foo3) $\delta^{13}C_{sc} = \alpha (\delta^{13}C_{b1} - \delta^{13}C_{b2}) + \delta^{13}C_{b2}$

This Bayesian model needs thus two baselines. In order to use this Bayesian model with your data, you need to use the following function:

```{r}
model.string <- jagsTwoBaselines()
```

As usual, you can define the *prior* distribution for all of the variables included within the equations (2) and (3), the parameter `TP` and the constand $\lambda$. For example, if you want to define a *prior* normal distribution for the mean of $\Delta$N, then you would have to do this:

```{r}
model.string <- jagsTwoBaselines(muDeltaN = "dnorm(3.4, 1)")
```

## Two baselines model, with TEF for Nitrogen and Carbon

Finally, the most complex model included in `tRophicPosition` is `jagsTwoBaselinesFull()`. This model implements the same equation of above (2), but the calculation of $\alpha$ is a little bit different, because it includes $\Delta$C:

(@foo4) $\alpha = (\delta^{13}C_{b2} - (\delta^{13}C_{sc} + \Delta C)) / (\delta^{13}C_{b2} + \delta^{13}C_{b1})$

In order to use this Bayesian model, you have to use it like this:

```{r}
model.string <- jagsTwoBaselinesFull()
```

By default, as the more simple models, the *prior* distributions defined are uninformative, and you can enrich the estimation of trophic position, including your *prior* knowledge. The random variables you can define are the same of the `jagsTwoBaselines()` model, plus $\mu_{\Delta C}$ and $\sigma_{\Delta C}$.

# Initializing the model and sampling the posterior estimates

Once you have loaded the isotope data, you have formatted it to use it with `tRophicPosition` and you have chosen a proper Bayesian model to calculate the trophic position itself, then you can sample the posterior of trophic position and other variables. For this, we need to initialize the Bayesian model, and then sample the posterior estimates of trophic position.

## Initializing the Bayesian model

In order to initialize the Bayesian model, we need to feed the Bayesian model we have selected before with data. This is done with the function `TPmodel()`.

If you were practicing with data while reading this vignette, you can use your own data. In the following example we will use a dataset that is included with the package. First we will delete the *Orestias* data set in case it exists:

```{r}
# In case you have the Object "Orestias" in memory we will delete it
remove(Orestias)
```

If you didn't play with the data above, probably you don't have `Orestias` in memory. In which case you will see a warning. After removing the object `Orestias` (we don't want to mix up the datasets), we will load the data that it is included within `tRophicPosition`, and we will see its structure:

```{r}
# Here we load the data set included within tRophicPosition
data(Orestias)

# And here we see the structure of the data set
str(Orestias)
```

As you see, it is a named list with 8 variables: $\delta^{13}$C and $\delta^{15}$N of the secondary consumer (the *Orestias chungarensis* fish, from the Altiplano), of the baseline 1 and baseline 2. Also we have in the data set $\Delta$N and $\Delta$C. If you look closer, there are some `NA` values we need to omit:

```{r}
# Here we omit the NA values, and assign the output to the IsotopeData variable
Isotope.Orestias <- lapply(Orestias, na.omit)

# And then we can screen the dataset, after having omited the NA values
screenIsotopeData(Isotope.Orestias)
```

And now we are ready to initialize the Bayesian model. We will use the `jagsTwoBaselinesFull()` model. The process is really simple:

```{r}
# Here we define the Bayesian model
model.string <- jagsTwoBaselinesFull()
```

```{r}
# And here we initialize the model
model.Orestias <- TPmodel(data = Isotope.Orestias,
                 model.string = model.string)
```

You can optionally define the number of chains sampled, and the number of adaptive iterations. This is done by including the following arguments:

```{r eval=FALSE}
# By default, TPmodel() samples 2 chains with 10000 adaptive iterations
# Here we will sample 4 chains with 20000 adaptive iterations each
model.Orestias <- TPmodel(data = Isotope.Orestias,
                 model.string = model.string,
                 n.chains = 4,
                 n.adapt = 20000)
```

## Sampling and plotting the posterior of trophic position

The task of sampling the posterior of trophic position estimates is really simple. You just have to use the Bayesian model you have initialised above. If you don't define explicitly the variables you want to monitor, `posteriorTP()` will monitor by default `TP` and `muDeltaN`.

```{r}
samples.Orestias <- posteriorTP(model.Orestias)
```

When you have a posterior sample of trophic position, you can plot it with:

```{r}
plot(samples.Orestias)
```

In the graph above you have four subgraphs. You will see the trace and density of posterior estimates of `TP` and `muDeltaN`. As we set up 4 chains, you should see 4 colors in the trace of both variables, each color represents one chain sampled.

You can also plot the data with the function `trophicDensityPlot()`. This functions receives a data frame with two variables: `TP` and `Species`, where `TP` are the posterior samples of trophic position, and `Species` is a factor. We can plot the quantiles (95% of credibility interval, plus median and mean). In order to plot the data with this function, we have extract the data:

```{r}
# Here we save the posterior samples of trophic position (only first chain)
Orestias.TP <- as.data.frame(samples.Orestias[[1]][,"TP"])$var1

# And then we combine it with the posterior samples from the second chain
Orestias.TP <- c(Orestias.TP,as.data.frame(samples.Orestias[[2]][,"TP"])$var1)

# And we check the length of the variable we created
length(Orestias.TP)
```

Now, we create the data frame:

```{r}
# With this code we make the Species variable
Species <- c(rep("Orestias chungarensis", length(Orestias.TP)))

# and then we combine it with the posterior sample of Orestias trophic position
df <- data.frame(Orestias.TP, Species)
```

We need the data frame has the variable names `TP` and `Species`, so we need to change the names accordingly:

```{r}
# Changing the variable names  of the dataframe "df"
colnames(df) <- c("TP", "Species")

# We check if everything went good
summary(df)
```

And finally, plot it:

```{r}
trophicDensityPlot(df)
```

# Resuming: trophic position in a nutshell

So, in a few words, in order to use `tRophicPosition` you have to:

```{r}
# Load data into R
data(Trout)
```

The Trout dataset is included with `tRophicPosition`. These isotope values corresponds to sympatric Rainbow trout *Onchorhynchus mykiss* that is found with *Orestias chungarensis* in the Chungará river, in the Altiplano of Chile.

```{r}
# Omit the NA values (if there are)
Isotope.Trout <- lapply(Trout, na.omit)

# Screen the isotope data
screenIsotopeData(Isotope.Trout)
```

As you see, the Rainbow trout is much more variable than the *Orestias* (in the isotopic biplot space). We will use the `jagsTwoBaselinesFull()` model to calculate the trophic position.

```{r}
# Here we choose the Bayesian model
model.string <- jagsTwoBaselinesFull()

# And then initialize the Bayesian model with data
model.Trout <- TPmodel(Isotope.Trout, model.string)
```

Now that we have initialized the model, we sample the posterior and plot the data.

```{r}
# Here we sample the posterior trophic position
samples.Trout <- posteriorTP(model.Trout)

# Then we summarize the posterior data
summary(samples.Trout)

# And plot it
plot(samples.Trout)
```

Finally, we extract the posterior trophic position samples, and save them into a variable:

```{r}
# Here we extract the first chain
Trout.TP <- as.data.frame(samples.Trout[[1]][,"TP"])$var1

# Here we extract the second chain
Trout.TP <- c(Trout.TP,as.data.frame(samples.Trout[[2]][,"TP"])$var1)

# And we check the length of the variable, i.e. how many posterior values we have
length(Trout.TP)
```

## Comparing two trophic positions

Now we have posterior samples of two sympatric species in the Altiplano from Chile: *Orestias chungarensis* and *Onchorhynchus mykiss*. If you want to compare the trophic position of both species you can use the function `compareTwoDistributions()`. This function receives 2 posterior distributions and a test, and returns the probability of ocurring that comparison, in a Bayesian way. Check `?compareTwoDistributions()` for other details.

We have the *Orestias* posterior trophic position:
```{r}
summary(Orestias.TP)
```

And also we have the Rainbow trout posterior trophic position:
```{r}
summary(Trout.TP)
```

We want to know whether the *Orestias* is predating on a lower trophic position compared to the Rainbow trout. We ask whether "the posterior distribution of trophic position of *Orestias* is lower than the posterior distribution of Rainbow trout". With the function, we ask the folowing:

```{r}
compareTwoDistributions(Orestias.TP, Trout.TP, test = "<")
```

And according to the result, it is very, very unlikely that *Orestias* is predating on a lower trophic position than Rainbow trout. We can plot the results:

```{r}
#Now we build a data frame combining both TP and creating a Species factor
TP <- c(Orestias.TP, Trout.TP)
Species <- c(rep("Orestias chungarensis", length(Orestias.TP)),
             rep("Onchorhynchus mykiss", length(Trout.TP)))

df <- data.frame(TP, Species)

# Here we use the function for plotting trophic position grouped by the Species factor
# and without quantiles (the default)
trophicDensityPlot(df)
```

Because we have the same data as the package `SIBER` uses, we can borrow the `siberDensityPlot()` function:

```{r}
# First we combine the two posterior samples into a data frame
df2 <- data.frame(Orestias.TP, Trout.TP)

# Then we change the name of each column
colnames(df2) <- c("Orestias chungarensis", "Onchorhynchus mykiss")

# And then we plot the data
SIBER::siberDensityPlot(df2, xlab = "Species",
                        ylab = "Trophic Position")
```
